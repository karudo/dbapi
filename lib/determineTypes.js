// Generated by CoffeeScript 1.8.0
var builder, defaultTypesMap, getType, isArray, objectStr, toString, undefinedStr;

undefinedStr = 'undefined';

objectStr = 'object';

toString = Object.prototype.toString;

isArray = Array.isArray;

defaultTypesMap = {
  buffer: {
    type: 'blob',
    cbUnwrap: function(v) {
      return new Buffer(v);
    }
  },
  date: {
    type: 'date',
    cbUnwrap: function(v) {
      return new Date(v);
    }
  }
};

getType = function(object) {
  var type;
  type = typeof object;
  if (type === undefinedStr) {
    return undefinedStr;
  }
  type = object ? object.constructor.name : toString.call(object).slice(8, -1);
  return type.toLowerCase();
};

builder = function(options) {
  var determineTypes, sep, typesMap;
  if (options == null) {
    options = {};
  }
  typesMap = options.typesMap, sep = options.sep;
  if (!typesMap) {
    typesMap = defaultTypesMap;
  }
  sep || (sep = '.');
  determineTypes = function(item, pathesSkip) {
    var addKey, path, runner, types;
    if (isArray(pathesSkip)) {
      pathesSkip = pathesSkip.reduce((function(o, key) {
        if (isArray(key)) {
          key = key.join('.');
        }
        o[key] = true;
        return o;
      }), {});
    }
    path = [];
    types = [];
    addKey = function(k, type) {
      var pathArr;
      pathArr = path.concat(k);
      if (!(pathesSkip && pathesSkip[pathArr.join('.')])) {
        return types.push([pathArr, type]);
      }
    };
    runner = function(obj) {
      return each(obj, function(key, value) {
        var valueType;
        if (objectStr === typeof value) {
          valueType = getType(value);
          if (typesMap[valueType]) {
            return addKey(key, typesMap[valueType].type);
          } else {
            path.push(key);
            runner(value);
            return path.pop();
          }
        }
      });
    };
    runner(item);
    return types;
  };
  determineTypes.obj = function(item, pathesSkip) {
    return builder.a2o(determineTypes(item, pathesSkip), sep);
  };
  determineTypes.a2o = function(arr) {
    return builder.a2o(arr, sep);
  };
  determineTypes.o2a = function(obj) {
    return builder.o2a(obj, sep);
  };
  return determineTypes;
};

builder.a2o = function(arr, sep) {
  if (sep == null) {
    sep = '.';
  }
  return arr.reduce((function(obj, _arg) {
    var pathArr, type;
    pathArr = _arg[0], type = _arg[1];
    obj[pathArr.join(sep)] = type;
    return obj;
  }), {});
};

builder.o2a = function(obj, sep) {
  var path, type, _results;
  _results = [];
  for (path in obj) {
    type = obj[path];
    _results.push([path.split(sep), type]);
  }
  return _results;
};

module.exports = builder;
